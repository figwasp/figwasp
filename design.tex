\documentclass{article}

\title{\texttt{alduin} \\
    \large Keep Kubernetes Deployments up to Date \\
    with the \texttt{latest}\footnote{
        Or any other tag, for that matter.
    } \
    Container Images
}
\author{Joel Ling}
\date{\today \\
    \small Hokkaido, Japan
}

\begin{document}

\maketitle

\begin{abstract}
\texttt{alduin} is a Kubernetes sidecar
that automatically updates a deployment
when a newer image inherits the name and tag
of a currently-deployed image.
\end{abstract}

\tableofcontents

\section{Preface}

\section{Motivation}

\section{Context}
``It's time to go''

\pagebreak

\section{Details}

\subsection{Identify Target Deployment(s)}
To fulfill its purpose of updating a Kubernetes \textit{deployment},
\texttt{alduin} must obtain access to its target.
A deployment is most straightforwardly addressed by its name,
and the Kubernetes \textit{namespace} in which the deployment could be found.
To obtain these values,
a \texttt{DeploymentIdentifier} interface would be defined
to provide a method \texttt{IdentifyDeployment}.
It would be implemented by an \texttt{EnvironmentVariableDeploymentIdentifier}
that reads the namespace and deployment names from environment variables
assigned with those values.

In the event that a deployment is not specified,
\texttt{alduin} would target all deployments in a namespace,
which if also left undefined
must be assumed to be the \texttt{default} namespace.
For that purpose a \texttt{DeploymentLister} interface would be defined
to provide a method \texttt{ListDeployments},
which takes a namespace as an argument and
returns a collection of \texttt{Deployment} interfaces
representing deployments in that namespace.
\texttt{DeploymentLister} would be implemented
by a \texttt{V1APIClientDeploymentLister}
by means of a Go client to Version 1 of the Kubernetes API.

\texttt{DeploymentLister} would also provide a second method
\texttt{GetDeployment},
which takes a namespace and deployment name as arguments and
returns a collection containing only one \texttt{Deployment}
corresponding to that name.

\subsubsection{\texttt{V1APIClientDeploymentLister}}
A Go package \texttt{github.com/kubernetes/client-go/kubernetes}
(hereafter abbrieviated as ``\texttt{...kubernetes}'')
provides a function \texttt{NewForConfig}
that creates a new \texttt{Clientset} for the given config\footnote{
    The package \texttt{github.com/kubernetes/client-go/rest}
    provides \texttt{InClusterConfig},
    a function that returns a client config utilising the service account
    assigned to the pod within which \texttt{alduin} would be running.
}.
\texttt{Clientset} has a method \texttt{AppsV1}
that returns an \texttt{AppsV1Interface}
defined in package \texttt{...kubernetes/typed/apps/v1}.
As a composite interface embedding \texttt{DeploymentsGetter},
\texttt{AppsV1Interface} implements the method \texttt{Deployments},
which returns a \texttt{DeploymentInterface}.
The interface has methods \texttt{List} and \texttt{Get},
which \texttt{V1APIClientDeploymentLister} would invoke to obtain return values
of type \texttt{DeploymentList} and \texttt{Deployment} respectively.
The former is a collection of the latter,
as their names suggest.

\texttt{DeploymentInterface} is a reusable resource
that should be initialised and then passed to
the constructor of \texttt{V1APIClientDeploymentLister}
to be stored in an unexported field of the struct.
It can foreseeably be used by other interfaces in \texttt{alduin}
to make other deployment-related calls to the Kubernetes API.

\subsubsection{The \texttt{Deployment} Interface}
The methods of \texttt{alduin} interfaces should not interact directly
with structs returned by methods of \texttt{DeploymentInterface}
to avoid tight coupling with a particular client implementation (and version)
of the Kubernetes API.
Instead, a type \texttt{V1Deployment} wrapping the \texttt{Deployment} struct
would be declared.
It would carry the methods that satisfy the custom \texttt{Deployment} interface
decoupling the rest of \texttt{alduin} from Version 1
of the Kubernetes Go client.

The \texttt{Deployment} interface would also provide a method \texttt{Name}
to allow convenient access to deployment names.

\subsection{Identify Images to Monitor}
An \texttt{ImageLister} interface would be defined
to provide a method \texttt{ListImages},
which returns a collection of container image identifiers.
These identifiers are strings as is the case in \texttt{containerd}\footnote{
    See field \texttt{Image} of type \texttt{Container}
    in package \texttt{containers} in
    the \texttt{containerd} source code repository
    at \texttt{https://github.com/containerd/containerd}.
    A comment to the field \texttt{Name} of type \texttt{Image}
    in package \texttt{images}
    stating that an image name should be
    ``a reference compatible with resolvers''
    seems to suggest delegation of decisions about name format.
}.
They contain an image name and
optionally an image repository hostname, port number, path, as well as a tag,
following the convention popularised by Docker and adopted by Kubernetes.

Conceptually, there are many ways to obtain such a list of image identifiers,
including the extreme case of reading the list from an environment variable,
file or other forms of input.
However, since a deployment \textit{spec} contains information about images,
it is efficient to extract the list of deployed images from that.
The \texttt{Deployment} interface would therefore
embed the \texttt{ImageLister} interface.

\subsubsection{\texttt{Deployment.ListImages}}
Listing the images deployed in a deployment is merely
a matter of accessing field \texttt{.Spec.Template.Spec.Containers}
of a \texttt{Deployment} struct,
a slice of \texttt{Container} structs
defined in package \texttt{github.com/kubernetes/api/v1}.
The target string \texttt{Container.Image} would be appended
to the list of image identifiers that \texttt{ListImages} would return.

\subsection{Periodically Retrieve Image Digests}
The Open Container Initiative (OCI) image specifications state that
a digest is a string that uniquely identifies image contents.

An \texttt{ImageDigestRetriever} interface would be defined
to provide a method \texttt{RetrieveImageDigest},
which returns the digest of a container image given its identifier.
Although some implementations may require credentials
for authenticating to image repositories,
the interface does not assume
the necessity nor form of such additional arguments.

A \texttt{DockerClientImageDigestRetriever} would implement the interface
utilising the official Go client for the Docker Engine API.

\subsubsection{\texttt{DockerClientImageDigestRetriever}}
The Docker Engine API defines an endpoint \texttt{distribution/<name>/json},
which returns among other things the digest of an image given its name.
Package \texttt{github.com/moby/moby/client} provides a struct \texttt{Client}
that has a method \texttt{DistributionInspect} for accessing that endpoint.
It expects a \texttt{base64url}-encoded JSON ``identity token''
of format \texttt{\{"identitytoken": "<token>"\}},
where \texttt{<token>} is a value that can be obtained
by making a \texttt{POST} request to the \texttt{auth} endpoint
using another \texttt{Client} method \texttt{RegistryLogin}.

\subsection{Maintain Register of Image Digests}
An \texttt{ImageDigestRegister} interface would be defined
to provide a method \texttt{RegisterImageDigest}
that takes an image identifier and an image digest as arguments, and
associates the digest with the identifier.

\texttt{MapImageDigestRegister}, a Go map of type \texttt{map[string]string},
would implement the interface.

\subsection{Compare Present and Historical Image Digests}
Whereas the OCI image specifications define a digest format and
allow several digest algorithms,
\texttt{alduin} is only concerned with the absolute value of the digests,
since an image would always be pulled from the same repository
across versions, and
the digest format and algorithm is unlikely to vary.

\texttt{ImageDigestRegister} would provide a method
\texttt{CompareAgainstRecords}
that takes an image identifier and an image digest as arguments, and
returns a boolean indicating whether the digest differs from that in history.

\subsection{Update Deployment(s)}
A \texttt{DeploymentUpdater} interface would be defined
to provide \texttt{UpdateDeployment}, a method
that takes the name of a deployment as an argument and
causes Kubernetes to perform a rolling restart of that deployment,
downloading the latest image for each container in it if that image has changed,
contingent on the \texttt{imagePullPolicy} of those containers
set to \texttt{Always}.

A \texttt{PatchingDeploymentUpdater}
inspired by the workings behind the Kubernetes command-line tool
\texttt{kubectl} (discussed in greater detail below)
would implement the \texttt{DeploymentUpdater} interface.

\subsubsection{\texttt{PatchingDeploymentUpdater}}
\texttt{kubectl} accepts a command
\texttt{rollout restart deployment/<name>}\footnote{
    See example in section ``Updating resources'' of
    the \texttt{kubectl} Cheat Sheet
    at \texttt{https://kubernetes.io/docs/reference/kubectl/cheatsheet/}.
}
that triggers a rolling restart of a named deployment.
Under the hood, \texttt{kubectl} sends \texttt{PATCH} requests
to the Kubernetes (HTTP) API
that trigger a rollout of the deployment
by changing its pod template.
Specifically, it
updates the annotation \texttt{kubectl.kubernetes.io/restartedAt}
in the template metadata to an RFC3339 string representing the current time.
Evidence of such behaviour is found
in the unexported \texttt{defaultObjectRestarter} function
in the package \texttt{polymorphichelpers} in the \texttt{kubectl} source.
The function is passed as an argument
to another that prepares the patch request,
itself called by method \texttt{RunRestart} from package \texttt{cmd/rollout},
the method behind \texttt{rollout restart}.

\texttt{PatchingDeploymentUpdater} could use the \texttt{Patch} method
supplied by a \texttt{DeploymentInterface}
to send a \texttt{PATCH} request with a JSON body similar to the following,
essentially mimicking the behaviour of \texttt{kubectl}.

\begin{verbatim}
{
   "spec": {
      "template": {
         "metadata": {
            "annotations": {
               "alduin/restartedAt": "<timestamp>"
            }
         }
      }
   }
}
\end{verbatim}

\section{Testing}

\subsection{Mock Kubernetes Cluster}

\texttt{kind}

\subsection{Usage}
The user would need to create a Role or ClusterRole
with permissions to \texttt{get} and \texttt{patch} deployments.
The role would be bound to a service account, and
the \texttt{psychocomp} sidecar would be authenticated as that service account.

\end{document}
